In Quarkus there are two test dependencies, the JUnit5 and the rest-assured. When using the JUnit5 it must be noted that the Surfire Maven Plugin is set, as the default version does not support the JUnit5. The quarkus-junit5 is required for testing as this provides the @QuarkusTest annotations that control the testing framework. The rest-assured is not required but is used for convenient testing of HTTP endpoints. Quarkus also provides an integration that automatically sets the correct URL without configuration.
To ensure that the tests use the correct log manager the system property is set to java.util.logging.manager. Furthermore, maven.home is used to ensure that if present, the custom configuration from ${maven.home}/conf/settings.xml is applied. If a custom version of the settings.xml file is to be used for testing, the maven.settings must be configured. The project should include a simple test that uses HTTP. This test is used to test the REST endpoint directly. When running the test, the application is started first before running the test. 

1. control of the test port
Quarkus listens on port 8080 by default and uses port 8081 when running tests. This has the advantage that tests can be run in parallel with running applications. It is also possible to configure the test ports. Here, http.test-port for HTTP and quarkus.http.test-ssl-port for HTTPS must be set up in the properties of the application. If the value is set to 0, then the operating system used assigns a random port. 
Furthermore, Quarkus provides a REST Assured integration without any additional configuration. This uses the updated default port from REST Assured before executing the test. When using REST Assured, the connection and response timouts are set to 30 seconds, these can be changed with the quarkus.http.test-timeout property.

2. testing a final product
The REST Assured as well as the @TestHTTPResource allow instead of coordinating a fixed path to specify the testing endpoint class. This provides an easier overview to see which endpoints are being tested by specific tests. The @TestHTTPResource annotation makes it possible to inject the URL as well as the URI directly into the test, which simplifies the use of additional clients. It can also map the URL as a string representation. The use of REST Assured and @TestHTTPResource is currently supported by JAX-RS endpoints as well as servlets and Reactive Routes. 
The io.quarkus.test.common.http.TestHTTPEndpoint annotation specifies an endpoint path and extracts the specified path from the endpoint. The io.quarkus.test.common.http.TestHTTPEndpoint annotation is used to control the RESTassured base path. This annotation can be applied at class and method levels. 

3. test, transactions, interceptor and beans.
For the execution of unit tests and direct testing of the beans, CDI beans are injected into the test in Quarkus using the @Inject annotation. These CDI beans, provide all CDI functions. Therefore, CDI interceptors can be applied as usual. For example, the @Transactional annotation can be applied to a test method that is executed in context with a transaction. The transaction interceptor will recognize and apply this.
The standard @Transactional Quarkus annotation can also be applied to tests. However, it should be noted that all changes in the database caused by the test remain permanent. If this is not desired and the changes should be revoked after the test terminates, it is recommended to use the annotation io.quarkus.test.TestTransaction.

Additionally, the @QuarkusTest classes can implement callback interfaces. These callback interfaces are an alternative or an addition to the interceptor and must be set as "service providers", i.e. as java.util.ServiceLoader. The following callback interfaces are available:
•	io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback
•	io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback
•	io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback
•	io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback

The callback is controlled by the read annotations of the test class or test method. It is possible to use JUnit Jupiter callback interfaces, but problems can occur when loading the class, because Quarkus executes the tests in a custom class loader, which JUnit does not know.

4. tests of different profiles
First Quarkus is booted and then all the tests are run. After running the tests, Quarkus is shut down again at the end. This procedure allows very fast but limited testing. The reason for this is that different configurations are not tested. 
To solve this problem and to provide a high degree of flexibility, Quarkus supports test profiles. Here Quarkus is started depending on the profile, i.e. if the current test is not from the same profile as the previous test, then Quarkus is shut down and restarted with the appropriate profile. The disadvantage of this is that shutting down and starting Quarkus extends the test time by one cycle. To overcome this problem, it is recommended that all tests with the same profile be ordered alphabetically and in a separate package.

4.1 Writing a profile
Before a test profile can be implemented, the package io.quarkus.test.junit.QuarkusTestProfile must be implemented. To be able to determine if the previous test was executed with the same configuration, the entire configuration of a test profile is stored in a class. 

4.2 Execute a specific test
By combining the tags method of QuarkusTestProfile and the system property quarkus.test.profile.tags, it is possible in Quarkus to restrict the execution of tests to @TestProfile annotations. This means that in QuarkusTestProfile at least one tag must be identical with the value of quarkus.test.profile.tags, so that the system marks this test with @TestProfile to execute the profile. Any tests that are not tagged as active will be skipped. 

The following should be noted:
•	All tests will be executed if quarkus.test.profile.tags is not set.
•	quarkus.test.profile.tags=foo will result in no test being executed. The reason is that there is no match to the value of quarkus.test.profile.tags in the predefined QuarkusTestProfile. 

5. mock support
In Quarkus, mock objects can be supported in two different ways. 
The first variant is that the mock objects are used as CDI alternatives. This variant is used to mock a bean for all test classes. Beans that are to be mocked are overwritten with a class in the src/test/java directory. Then the annotations @Alternative and @Priority(1) are added to the overwritten bean. As an alternative, the stereotype annotation io.quarkus.test.Mock can be used, which contains @Alternative, @Priority(1) as well as @Dependent. It is important here that the @Alternative is present in the src/test/java directory and not in src/main/java, otherwise it will be effective outside the test. However, this approach does not work for tests of native images. 
The other variant is to use the QuarkusMock. In this case, one temporarily mocks the beans in each test individually. If this variant is used in a @BeforeAll method, then the mock will take effect for all tests in the current class. However, it is to be noted that the mock is effective with the use of a test method only as long as the duration of the current test. The QuarkusMock can be used for any CDI bean with scoping and does not depend on Mockito, but takes advantage of it. To achieve a desired behavior, any mocking library can be used and objects can be manually overridden if necessary.
The CDI proxy for the installed mock instance, which is obtained when using @Inject, is not suitable for passing methods such as Mockito.verify. To be able to call methods like verify, the mock instance must be handled in the test. Alternatively, @InjectMock can be used.
To use @RegisterRestClient to register the implementation of the rest client at runtime, the interface must be marked with the annotation @ApplicationScoped. 
By using quarkus-hibernate-orm-panache or quarkus-mongodb-panache it is easy to mirror the data access.  

6. starting services before the Quarkus application starts
Often there is a requirement to start some services that the Quarkus application depends on before the actual testing with Quarkus can be done. To address this issue, Quarkus provides @io.quarkus.test.common.QuarkusTestResource and io.quarkus.test.common.QuarkusTestResourceLifecycleManager. 
Here, the annotation @QuarkusTestResource must be present in each test-suite. Quarkus executes the corresponding QuarkusTestResourceLifecycleManager before starting a test. It is also possible to use multiple @QuarkusTestResource annotations in an execution definition. In this case Quarkus executes all corresponding QuarkusTestResourceLifecycleManager objects before starting the test. If multiple test resources are set, they can be started simultaneously using @QuarkusTestResource(parallel = true). It should be noted that even if test resources are defined for a class or a custom profile, they are still global. To use a test resource only for a class or test profile, it is recommended to use @QuarkusTestResource(restrictToAnnotatedClass = true). 
Quarkus provides multiple implementations of QuarkusTestResourceLifecycleManager for non-specific application requirements. For specific application requirements, it is advantageous to create your own implementations. If a custom QuarkusTestResourceLifecycleManager is created that needs to inject something into a test class, then inject methods can be used. It should be noted that these injections are performed only after the CDI has injected all necessary injections into the test class. These injections are not under the control of the CDI. 
It is also possible to write your own test resources. These test resources are activated and configured by annotations. Here the @QuarkusTestResource annotation must be set to an annotation, which executes the two functions.

7. detect hangs
With the help of the annotation @QuarkusTest unexpected hangs can be diagnosed. This is done by outputting a stack trace on the console if no JUnit callbacks are called after a certain time. The timeout is 10 minutes by default. To be able to continue the test, this timeout can be controlled with quarkus.test.hang-detection-timeout. 

8. testing native files
In Quarkus it is possible to test native executable files. This is done with the annotation @NativeImageTest. However, in the future the functionality of the @NativeImageTest will be covered by the @QuarkusIntegrationTest. This will be used to launch as well as test the artifact generated by the Quarkus build. It also supports testing native images and container images as well as jar files. The @QuarkusIntegrationTest is a black box test just like the @NativeImageTest, which includes the same features and limitations. It is important to note that the @QuarkusIntegrationTest should be run as part of the integration suite.  The reason for this is that if the tests are run in the same phase as @QuarkusTest, they will not work because the final artifact has not yet been created.
@QuarkusTests must not be mixed with other tests in a single execution run, such as a single Maven Surfire Plugin execution. This is because the @QuarkusTest, when running the entire execution flow, starts a Quarkus server and prevents other tests from starting their own Quarkus server. To work around this limitation the JUnit5 tag io.quarkus.test.junit.QuarkusTest is used.

Source: https://quarkus.io/guides/getting-started-testing
